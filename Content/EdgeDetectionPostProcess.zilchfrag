// Based on: jorge@iryoku.com/SMAA

[Pixel][PostProcess]
struct EdgeDetectionPostProcess
{
  
  [BuiltInInput] var InverseViewportSize : Real2;
  [StageInput] var Uv : Real2;
  [Input] var Texture : Sampler2d;
  [Input] var ComparisonThreshold : Real = 0.01;
  [Input] var ContrastAdaptationThreshold : Real = 2.0;
  [Output] var Target0 : Real4;

  function Main()
  { 
    
     var edge = Real2();

     var lumaComparisonThreshold = this.ComparisonThreshold;
     var lumaConstants = Real3(0.2126, 0.7152, 0.0722);
    
     // Calculate lumas for the current, left and top pixel
     var currentPixelLuma = Math.Dot(this.Texture.Sample(this.Uv).XYZ, lumaConstants);
     var leftPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(-this.InverseViewportSize.X, 0.0)).XYZ, lumaConstants);
     var topPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(0.0, -this.InverseViewportSize.Y)).XYZ, lumaConstants);
    
     // Delta luma among the current and left, top neighbors
     var changeInLumaLT = Math.Abs(currentPixelLuma.XX - Real2(leftPixelLuma, topPixelLuma));
    
     // We store edges as binary 0 or 1 for each pixel for the edges texture
     edge = Math.Step(lumaComparisonThreshold.XX, changeInLumaLT);
          
     // Compare the neighboring fragments and discard if the luma differnce below threshold.
     // We want the threshold to be <= changeInLuma, otherwise not edge.
     if (Math.Dot(edge, Real2(1.0, 1.0)) == 0.0)
        Shader.Discard();
        
      // Calculate lumas for the right and bottom pixel.
     var rightPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(this.InverseViewportSize.X, 0.0)).XYZ, lumaConstants);
     var bottomPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(0.0, this.InverseViewportSize.Y)).XYZ, lumaConstants);
    
     // Delta luma among the current and right,bottom neighbors.
     var changeInLumaRB = Real2(Math.Abs(currentPixelLuma.XX - Real2(rightPixelLuma, bottomPixelLuma)));
    
     // Maximum change across direct neighbors.
     var maxChangeInLuma = Math.Max(changeInLumaLT, changeInLumaRB);
    
     // Calculate lumas for the left-left and top-top pixel.
     var leftLeftPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(-2.0 * this.InverseViewportSize.X, 0.0)).XYZ, lumaConstants);
     var topTopPixelLuma = Math.Dot(this.Texture.Sample(this.Uv + Real2(0.0, -2.0 * this.InverseViewportSize.Y)).XYZ, lumaConstants);
     var changeInLumaLLTT = Math.Abs(Real2(leftPixelLuma, topPixelLuma) - Real2(leftLeftPixelLuma, topTopPixelLuma));

     // Consider the ll and tt pixels for contrast adaptation.
     maxChangeInLuma = Math.Max(maxChangeInLuma, changeInLumaLLTT);
     var overallMax = Math.Max(maxChangeInLuma.X, maxChangeInLuma.Y);
     
     // Local contrast adaptation: Human eyes don't detect edges with lower contrast over higher ones if they are close
     // to each other on a given pixel, we ignore the edges with lower contrast below a threshold to avoid visaul artifacts
     // hence, we only let an edge pass if it is atleast 0.5x the maxChangeInLuma(overall).
     edge *= Math.Step(overallMax.XX, changeInLumaLT * this.ContrastAdaptationThreshold);
     
     // Edge is a 2D binary representing pixel with left/top edges as red and green colors respectively. 
     this.Target0 = Real4(edge, 0, 1);
    
  }
}
